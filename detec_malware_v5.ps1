# SCRIPT PowerShell para Análise Forense Avançada de Extensões de Navegadores Chromium
# AUTOR: Engenharia de Segurança Sênior
# VERSÃO: 3.1 (Correção de ParserError e Refinamento de Sintaxe)
# DESCRIÇÃO: Esta ferramenta profissional realiza uma análise forense detalhada de extensões
#            de navegadores Chromium, com foco em código limpo, testabilidade e expansibilidade futura.

[CmdletBinding(SupportsShouldProcess = $true)]
param (
    [Parameter(Mandatory = $false)]
    [string]$VirusTotalApiKey = "5d55c7f986ee410f3904800a427c81839696e23600be6ff2f7c074cb939707ae",
    
    [Parameter(Mandatory = $false)]
    [string[]]$SuspectExtensionIDs = @("elpdbicokgbedckgblmbhoamophfbchi"),
    
    [Parameter(Mandatory = $false)]
    [string]$TargetUserSID,
    
    [Parameter(Mandatory = $false)]
    [switch]$DiscoverProfiles,
    
    [Parameter(Mandatory = $false)]
    [string]$OutputDirectory = (Join-Path -Path $env:USERPROFILE -ChildPath "Desktop\SecurityAnalysis")
)

#================================================================================
# BLOCO DE CONFIGURAÇÃO CENTRALIZADO
#================================================================================
$Config = @{
    Browsers = @(
        @{
            Name = "Google Chrome"
            UserDataPath = "AppData\Local\Google\Chrome\User Data"
            RegistryPathPatterns = @(
                "Software\Google\Chrome\PreferenceMACs\Default\extensions.settings",
                "Software\Google\Chrome\PreferenceMACs\Profile *\extensions.settings"
            )
        },
        @{
            Name = "Microsoft Edge"
            UserDataPath = "AppData\Local\Microsoft\Edge\User Data"
            RegistryPathPatterns = @(
                "Software\Microsoft\Edge\PreferenceMACs\Default\extensions.settings",
                "Software\Microsoft\Edge\PreferenceMACs\Profile *\extensions.settings"
            )
        }
    )
    HighRiskPermissions = @( "<all_urls>", "tabs", "webRequest", "webRequestBlocking", "proxy", "cookies", "history", "bookmarks", "management", "nativeMessaging", "scripting", "debugger", "unlimitedStorage" )
}

#================================================================================
# FUNÇÕES AUXILIARES E DE APOIO
#================================================================================
function Write-Log {
    param([string]$Message, [string]$Level = "INFO")
    $LogEntry = "[{0}] [{1}] {2}" -f $Level, (Get-Date -Format 'yyyy-MM-dd HH:mm:ss'), $Message
    Add-Content -Path $MasterLogPath -Value $LogEntry
    $Color = @{"INFO" = "Green"; "WARN" = "Yellow"; "ERROR" = "Red"; "VERBOSE" = "Cyan" }[$Level]
    if ($Color) { Write-Host $LogEntry -ForegroundColor $Color } else { Write-Host $LogEntry }
}

function Get-FileSha256 {
    param([string]$FilePath)
    try {
        $stream = [System.IO.File]::OpenRead($FilePath)
        $sha256 = [System.Security.Cryptography.SHA256]::Create()
        $hashBytes = $sha256.ComputeHash($stream)
        $stream.Close(); $stream.Dispose()
        return [System.BitConverter]::ToString($hashBytes).Replace('-', '').ToLower()
    } catch { return "HASH_ERROR" }
}

function Query-VirusTotal {
    param([string]$FileHash, [string]$ApiKey)
    if (-not $ApiKey) { return "API Key não fornecida" }
    $uri = "https://www.virustotal.com/api/v3/files/$FileHash"
    try {
        $response = Invoke-RestMethod -Uri $uri -Headers @{ "x-apikey" = $ApiKey } -Method Get -ErrorAction Stop
        $stats = $response.data.attributes.last_analysis_stats
        return "Detectado por $($stats.malicious) / $($stats.harmless + $stats.malicious + $stats.suspicious + $stats.undetected) motores."
    } catch {
        if ($_.Exception.Response.StatusCode -eq '404') { return "Hash não encontrado no VirusTotal." }
        return "Erro ao consultar VirusTotal: $($_.Exception.Message)"
    }
}

#================================================================================
# FUNÇÕES PRINCIPAIS (LÓGICA DE NEGÓCIO)
#================================================================================

function Get-UserProfiles {
    Write-Verbose "Buscando perfis de usuário em 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList'"
    $ProfileListPath = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList"
    return Get-ChildItem -Path $ProfileListPath | 
           Where-Object { $_.PSChildName -like 'S-1-5-21-*' } | 
           ForEach-Object {
               [PSCustomObject]@{
                   SID = $_.PSChildName
                   ProfilePath = Get-ItemProperty -Path $_.PSPath | Select-Object -ExpandProperty ProfileImagePath
               }
           }
}

function Get-ExtensionsFromRegistry {
    param([string]$UserSID)
    
    $foundExtensionIDs = [System.Collections.Generic.List[string]]::new()
    
    foreach ($browser in $Config.Browsers) {
        Write-Verbose "Procurando extensões do $($browser.Name) para o SID $UserSID"
        foreach ($pattern in $browser.RegistryPathPatterns) {
            $registryPath = "Registry::HKEY_USERS\$UserSID\$pattern"
            foreach ($item in (Get-Item -Path $registryPath -ErrorAction SilentlyContinue)) {
                $properties = Get-ItemProperty -LiteralPath $item.PSPath
                $properties.PSObject.Properties | ForEach-Object {
                    if ($_.Name.Length -eq 32 -and $_.Name -match '^[a-z]{32}$') {
                        if (-not $foundExtensionIDs.Contains($_.Name)) {
                            $foundExtensionIDs.Add($_.Name)
                        }
                    }
                }
            }
        }
    }
    return $foundExtensionIDs
}

function Get-ExtensionDetails {
    param([string]$ExtensionID, [PSCustomObject]$User, [string[]]$KnownSuspects, [hashtable]$Config)
    
    $extensionData = [PSCustomObject]@{
        ExtensionID = $ExtensionID; RiskScore = 0; RiskHeuristics = [System.Collections.Generic.List[string]]::new();
        IsKnownSuspect = $KnownSuspects -contains $ExtensionID; FoundOnDisk = $false; Name = "N/A"; Version = "N/A";
        Path = "N/A"; ManifestHash_SHA256 = "N/A"; VirusTotalResult = "N/A";
        HighRiskPermissions = [System.Collections.Generic.List[string]]::new(); FileHashes_SHA256 = @{}; Warnings = ""
    }
    if ($extensionData.IsKnownSuspect) { $extensionData.RiskScore += 10; $extensionData.RiskHeuristics.Add("ID da extensão corresponde a uma ameaça conhecida.") }

    $manifestPath = $null
    foreach ($browser in $Config.Browsers) {
        $userDataPath = Join-Path -Path $User.ProfilePath -ChildPath $browser.UserDataPath
        $searchPattern = Join-Path -Path $userDataPath -ChildPath "*\Extensions\$ExtensionID\*"
        $latestDir = Get-ChildItem -Path $searchPattern -Directory -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1
        
        if ($latestDir) {
            $testPath = Join-Path -Path $latestDir.FullName -ChildPath "manifest.json"
            if (Test-Path $testPath) {
                $manifestPath = $testPath
                $extensionData.Path = $latestDir.FullName
                break
            }
        }
    }

    if ($manifestPath) {
        $extensionData.FoundOnDisk = $true
        $extensionData.ManifestHash_SHA256 = Get-FileSha256 -FilePath $manifestPath
        if ($PSBoundParameters.ContainsKey('VirusTotalApiKey')) { $extensionData.VirusTotalResult = Query-VirusTotal -FileHash $extensionData.ManifestHash_SHA256 -ApiKey $VirusTotalApiKey }
        
        try {
            $manifest = Get-Content $manifestPath -Raw | ConvertFrom-Json -ErrorAction Stop
            
            $extensionData.Name = $manifest.name
            $extensionData.Version = $manifest.version

            if ($manifest.update_url -and $manifest.update_url -notlike "*google.com*") { 
                $extensionData.RiskScore += 5
                $extensionData.RiskHeuristics.Add("URL de atualização não aponta para o domínio do Google.")
            }
            if ($manifest.permissions) {
                $riskyPermissions = $manifest.permissions | Where-Object { $Config.HighRiskPermissions -contains $_ }
                if ($riskyPermissions) { 
                    $extensionData.RiskScore += ($riskyPermissions.Count * 2)
                    $extensionData.HighRiskPermissions.AddRange($riskyPermissions)
                    $extensionData.RiskHeuristics.Add("Solicita permissões de alto risco.")
                }
            }
            if ($manifest.background) { 
                $extensionData.RiskScore += 3
                $extensionData.RiskHeuristics.Add("Contém scripts de fundo persistentes.")
            }
            if ($manifest.content_scripts) { 
                $extensionData.RiskScore += 3
                $extensionData.RiskHeuristics.Add("Injeta scripts de conteúdo em páginas web.")
            }
            
            # ✅✅✅ CORREÇÃO DE SINTAXE APLICADA AQUI ✅✅✅
            # A condição foi reescrita de forma mais explícita para evitar o ParserError.
            if (($extensionData.RiskScore > 5) -or ($extensionData.IsKnownSuspect)) {
                Get-ChildItem -Path $extensionData.Path -Recurse -File | ForEach-Object { 
                    $relativePath = $_.FullName.Replace($extensionData.Path + '\', '')
                    $extensionData.FileHashes_SHA256[$relativePath] = Get-FileSha256 -FilePath $_.FullName 
                }
            }

        } catch { 
            $extensionData.Warnings = "Erro ao parsear manifest.json: $($_.Exception.Message)" 
        }
    } else {
        $extensionData.Warnings = "Manifest.json não encontrado no disco."
        $extensionData.RiskScore += 2
        $extensionData.RiskHeuristics.Add("Órfão no registro: arquivos não encontrados.")
    }
    return $extensionData
}

#================================================================================
# FLUXO DE EXECUÇÃO PRINCIPAL
#================================================================================

# --- 1. Inicialização ---
$ScriptStartTime = Get-Date
$Timestamp = $ScriptStartTime.ToString("yyyyMMdd_HHmmss")
$LogFileName = "Master_Analysis_Log_$Timestamp.log"
if (-not (Test-Path $OutputDirectory)) { New-Item -ItemType Directory -Path $OutputDirectory -Force | Out-Null }
$MasterLogPath = Join-Path -Path $OutputDirectory -ChildPath $LogFileName

Write-Log "--- Início da Análise Forense Avançada de Extensões (v3.1) ---"
Write-Log "Relatórios serão salvos em: $OutputDirectory"

# --- 2. Descoberta de Usuários ---
$targetUsers = @()
if ($DiscoverProfiles) {
    Write-Log "Modo Descoberta: Procurando todos os perfis de usuário..."
    $targetUsers = Get-UserProfiles
} elseif ($TargetUserSID) {
    Write-Log "Modo Alvo: Analisando SID $TargetUserSID"
    $targetUsers = Get-UserProfiles | Where-Object { $_.SID -eq $TargetUserSID }
} else {
    Write-Log "ERRO: Nenhum SID alvo especificado (-TargetUserSID) ou modo de descoberta (-DiscoverProfiles) ativado." "ERROR"
    exit 1
}
Write-Log "Encontrados $($targetUsers.Count) perfis de usuário para análise."

# --- 3. Análise por Usuário ---
foreach ($user in $targetUsers) {
    Write-Log "Iniciando análise para o usuário $($user.SID)..."
    $userReportDir = Join-Path -Path $OutputDirectory -ChildPath $user.SID
    if (-not (Test-Path $userReportDir)) { New-Item -ItemType Directory -Path $userReportDir -Force | Out-Null }
    
    $extensionIDs = Get-ExtensionsFromRegistry -UserSID $user.SID
    if ($extensionIDs.Count -eq 0) {
        Write-Log "Nenhuma extensão encontrada no registro para o usuário $($user.SID)."
        continue
    }
    
    $analysisResults = @()
    foreach ($id in $extensionIDs) {
        Write-Verbose "Analisando detalhes da extensão $id para o usuário $($user.SID)"
        $details = Get-ExtensionDetails -ExtensionID $id -User $user -KnownSuspects $SuspectExtensionIDs -Config $Config -VirusTotalApiKey $VirusTotalApiKey
        $analysisResults += $details
    }
    
    # --- 4. Geração de Relatórios ---
    $analysisResults = $analysisResults | Sort-Object RiskScore -Descending
    $reportPathTxt = Join-Path -Path $userReportDir -ChildPath "ForensicReport_$Timestamp.txt"
    $reportPathJson = Join-Path -Path $userReportDir -ChildPath "ForensicReport_$Timestamp.json"

    # Relatório TXT
    "--- Relatório de Análise Forense ---`nData: $(Get-Date)`nUsuário (SID): $($user.SID)`n---" | Out-File $reportPathTxt
    foreach ($ext in $analysisResults) {
        $status = if ($ext.IsKnownSuspect) { "AMEAÇA CONHECIDA" } elseif ($ext.RiskScore -ge 10) { "RISCO ALTO" } elseif ($ext.RiskScore -ge 5) { "RISCO MÉDIO" } else { "RISCO BAIXO" }
        $reportBlock = @"
======================================================================
ID da Extensão: $($ext.ExtensionID)
Status: $status (Pontuação de Risco: $($ext.RiskScore))
----------------------------------------------------------------------
Nome da Extensão:  $($ext.Name)
Versão:            $($ext.Version)
Caminho no Disco:    $($ext.Path)
Hash do Manifesto: $($ext.ManifestHash_SHA256)
Consulta VirusTotal: $($ext.VirusTotalResult)
Heurísticas de Risco Acionadas: $($ext.RiskHeuristics -join '; ')
Avisos: $($ext.Warnings)
======================================================================
"@
        $reportBlock | Add-Content -Path $reportPathTxt
    }
    
    # Relatório JSON
    $analysisResults | ConvertTo-Json -Depth 5 | Out-File -Path $reportPathJson -Encoding UTF8
    Write-Log "Análise para $($user.SID) concluída. Relatórios salvos em '$userReportDir'."
}

Write-Log "--- Análise Forense Concluída ---"
Write-Host "`nAnálise completa. Verifique os relatórios no diretório: $OutputDirectory" -ForegroundColor Green